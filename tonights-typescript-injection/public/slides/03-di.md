## ðŸ’‰ DI

---

> "In version of control"

Or

<!-- .element class="fragment" data-fragment-index="0" -->

> "Inversion of control"

<!-- .element class="fragment" data-fragment-index="0" -->

?

<!-- .element class="fragment" data-fragment-index="0" -->

---

### Inversion of Control (IoC)

It's about changing the flow of a program

> [...] object interactions that are defined through abstractions. This run-time binding is achieved by mechanisms such as dependency injection or a service locator.
> <cite>In Wikipedia. https://en.wikipedia.org/wiki/Inversion_of_control</cite>

---

![](/img/memes/ioc.jpg)

---

### An example

<div class="flex">

```ts [1-500|10]
const logger = {
  info(message: string) {
    console.log(message);
  },
};

class HttpClient {
  get<T>(url: string): Promise<T> {
    const response = await fetch(url);
    logger.info(`HTTP Get ${url}`);
    return response.json();
  }
}
```

<!-- .element class="xs" -->
<!-- prettier-ignore-start -->

```ts [1-500|2]
class MovieService {
  private client = new HttpClient();

  getAll(): Promise<Movie[]> {
    return this.client
      .get<Movie[]>('api/movies');
  }
}

const movies = new MovieService();
movies.getAll();
```

<!-- prettier-ignore-end -->

<!-- .element class="xs" -->

</div>

Normal control flow

---

### Inverted example

<div class="flex">

```ts [1-500|8]
const logger = {
  info(message: string) {
    console.log(message);
  },
};

class HttpClient {
  constructor(private log: typeof logger) {}

  get<T>(url: string): Promise<T> {
    const response = await fetch(url);
    this.log.info(`HTTP Get ${url}`);
    return response.json();
  }
}
```

<!-- .element class="xs" -->
<!-- prettier-ignore-start -->

```ts [1-500|2,10-11]
class MovieService {
  constructor(private client: HttpClient) {}

  getAll(): Promise<Movie[]> {
    return this.client
      .get<Movie[]>('api/movies');
  }
}

const movies = new MovieService(
  new HttpClient(logger));
movies.getAll();
```

<!-- prettier-ignore-end -->

<!-- .element class="xs" -->

</div>

Control flow is inverted (IoC)

---

### Hollywood Principle

![](/img/memes/call.jpg)

---

### IoC advantages

- **Decoupled** <small>by default</small>
- **Focus** <small>on the task at hand</small>
- <small>Rely on</small> **contract**
- **Testable** <small>from the ground up</small>

---

### DI popularity

![](/img/memes/popular.png)

Why no popular?

---

### Loosely coupled by default

```ts
class HttpClient {
  get<T>(url: string): Promise<T> {
    const response = await fetch(url);
    logger.info(`HTTP Get ${url}`);
    return response.json();
  }
}

let intercepted;
logger.info = (message) => {
  intercepted = message;
};
new HttpClient().get<Movie[]>('api/movies');
intercepted;
// ðŸ‘† 'HTTP Get api/movies'
```

---

### Lose coupling limitations

Module boundaries are especially difficult.
